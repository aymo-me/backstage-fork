/*! For license information please see a29ab470.e81769a7.js.LICENSE.txt */
"use strict";(self.webpackChunkbackstage_microsite=self.webpackChunkbackstage_microsite||[]).push([[241603],{182864:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>d,frontMatter:()=>r,metadata:()=>o,toc:()=>l});var t=s(474848),i=s(28453);const r={id:"call-existing-api",title:"Call Existing API",description:"Describes the various options that Backstage frontend plugins have, in communicating with service APIs that already exist"},a=void 0,o={id:"plugins/call-existing-api",title:"Call Existing API",description:"Describes the various options that Backstage frontend plugins have, in communicating with service APIs that already exist",source:"@site/versioned_docs/version-stable/plugins/call-existing-api.md",sourceDirName:"plugins",slug:"/plugins/call-existing-api",permalink:"/docs/plugins/call-existing-api",draft:!1,unlisted:!1,editUrl:"https://github.com/backstage/backstage/edit/master/docs/plugins/call-existing-api.md",tags:[],version:"stable",frontMatter:{id:"call-existing-api",title:"Call Existing API",description:"Describes the various options that Backstage frontend plugins have, in communicating with service APIs that already exist"},sidebar:"docs",previous:{title:"Backend plugins",permalink:"/docs/plugins/backend-plugin"},next:{title:"Testing with Jest",permalink:"/docs/plugins/testing"}},c={},l=[{value:"Issuing Requests Directly",id:"issuing-requests-directly",level:2},{value:"Using The Backstage Proxy",id:"using-the-backstage-proxy",level:2},{value:"Creating a Backstage Backend Plugin",id:"creating-a-backstage-backend-plugin",level:2}];function h(e){const n={a:"a",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"This article describes the various options that Backstage frontend plugins have,\nin communicating with service APIs that already exist. Each section below\ndescribes a possible choice, and the circumstances under which it fits."}),"\n",(0,t.jsx)(n.p,{children:"In these examples, we will be ultimately requesting data from the fictional\nFrobsCo API."}),"\n",(0,t.jsx)(n.h2,{id:"issuing-requests-directly",children:"Issuing Requests Directly"}),"\n",(0,t.jsxs)(n.p,{children:["The most basic choice available is to issue requests directly from the plugin\nfrontend code to the FrobsCo API, using for example ",(0,t.jsx)(n.code,{children:"fetch"})," or a support library\nsuch as ",(0,t.jsx)(n.code,{children:"axios"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"Example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:'title="plugins/my-awesome-plugin/src/components/AwesomeUsersTable.tsx"',children:"import useAsync from 'react-use/esm/useAsync';\n\nfunction AwesomeUsersTable() {\n  const {\xa0value, loading, error } = useAsync(async () => {\n    const response = await fetch('https://api.frobsco.com/v1/list');\n    return response.json();\n  }, []);\n\n\n  ...\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"Internally at Spotify, this has not been a very common choice. Third party APIs\nare sometimes accessed like this. Just a handful of internal APIs also went\nthrough the trouble of exposing themselves in a way that is useful directly from\na browser, but even then, often not from the public internet but only supporting\nusers that are already on the company VPN."}),"\n",(0,t.jsx)(n.p,{children:"This can be used when:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The API already does/exposes exactly what you need."}),"\n",(0,t.jsx)(n.li,{children:"The request/response patterns of the API match real world usage needs in\nBackstage frontend plugins. For example, if the end use case is to show a\nsmall summary in Backstage, but the only available API endpoint gives a 30\nmegabyte blob with large amounts of redundant information, it would hurt the\nend user experience. Particularly on mobile. The same goes for cases where you\nwant to show many individual pieces of information: if a common use case is to\nshow large tables where one API request per cell is necessary, the browser\nwill quickly become swamped and you may want to consider performing\naggregation elsewhere instead."}),"\n",(0,t.jsx)(n.li,{children:"The API can maintain interactive request/response times at your required peak\nrequest rates. The end user experience will be degraded if they spend a lot of\ntime waiting for the data to arrive."}),"\n",(0,t.jsx)(n.li,{children:"The API endpoint is highly available. The browser does not have builtin\nfacilities for load balancing, service discovery, retries, health checks,\ncircuit breaking and similar. If the endpoint is occasionally down even for\nshort periods of time (e.g. during deploys), end users will quickly notice."}),"\n",(0,t.jsxs)(n.li,{children:["The API is exposed over HTTPS (not just HTTP), and properly handles\n",(0,t.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS",children:"CORS"}),". These are\nrequirements that the user's browser will impose for security reasons, and the\nrequests will be rejected otherwise."]}),"\n",(0,t.jsx)(n.li,{children:"The API endpoint is easily reachable, in terms of network conditions, by end\nusers. This may be particularly relevant if your end users are outside of your\nperimeter."}),"\n",(0,t.jsx)(n.li,{children:"The requests do not require secrets to be passed. This limitation does not\napply to OAuth tokens, which the frontend can negotiate and make proper use\nof."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"using-the-backstage-proxy",children:"Using The Backstage Proxy"}),"\n",(0,t.jsx)(n.p,{children:"Backstage has an optional proxy plugin for the backend, that can be used to\neasily add proxy routes to downstream APIs."}),"\n",(0,t.jsx)(n.p,{children:"Example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"# In app-config.yaml\nproxy:\n  '/frobs': http://api.frobsco.com/v1\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",metastring:'title="plugins/frobs-aggregator/src/components/FrobsAggregator.tsx"',children:"import {\n  useApi,\n  discoveryApiRef,\n  fetchApiRef,\n} from '@backstage/core-plugin-api';\nimport useAsync from 'react-use/esm/useAsync';\n\nfunction FrobsAggregator() {\n  const fetchApi = useApi(fetchApiRef);\n  const discoveryApi = useApi(discoveryApiRef);\n\n  const { value, loading, error } = useAsync(async () => {\n    const baseUrl = await discoveryApi.getBaseUrl('proxy');\n    const response = await fetchApi.fetch(`${baseUrl}/frobs`);\n    return response.json();\n  }, [fetchApi, discoveryApi]);\n\n  // ...\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The proxy is powered by the ",(0,t.jsx)(n.code,{children:"http-proxy-middleware"})," package. See\n",(0,t.jsx)(n.a,{href:"/docs/plugins/proxying",children:"Proxying"})," for a full description of its configuration options."]}),"\n",(0,t.jsx)(n.p,{children:"Internally at Spotify, the proxy option has been the overwhelmingly most popular\nchoice for plugin makers. Since we have DNS-based service discovery in place and\na microservices framework that made it trivial to expose plain HTTP, it has been\na matter of just adding a few lines of Backstage config to get the benefit of\nbeing easily and robustly reachable from users' web browsers as well."}),"\n",(0,t.jsx)(n.p,{children:"This may be used instead of direct requests, when:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"You need to perform HTTPS termination and/or CORS handling, because the API\nitself is not supplying those."}),"\n",(0,t.jsx)(n.li,{children:"You need to inject a simple static secret into the requests, e.g. an\nAuthorization header that gets added to the request headers."}),"\n",(0,t.jsx)(n.li,{children:"You want to make use of other proxy facilities, such as retries, failover,\nhealth checks, routing, request logging, rewrites, etc."}),"\n",(0,t.jsx)(n.li,{children:"You already have the Backstage backend itself exposed through your perimeter\nand find it practical to have only one entry point to deal with, governing\ningress with just the Backstage config."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"creating-a-backstage-backend-plugin",children:"Creating a Backstage Backend Plugin"}),"\n",(0,t.jsx)(n.p,{children:"Much like the Backstage frontend, the Backstage backend also has a plugin\nsystem. The above mentioned proxy is actually one such plugin. If you were in\nneed of a more involved integration than just direct access to the FrobsCo API,\nor if you needed to hold state, you may want to make such a plugin."}),"\n",(0,t.jsxs)(n.p,{children:["For example, assuming you have created a new backend plugin called\n",(0,t.jsx)(n.code,{children:"frobs-aggregator"}),", you can add a new route like this:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",metastring:'title="plugins/frobs-aggregator-backend/src/router.ts"',children:"import Router from 'express-promise-router';\n\nexport async function createRouter() {\n  const router = Router();\n  router.use(express.json());\n\n  /* highlight-add-start */\n  router.get('/summary', async (req, res) => {\n    const agg = await Promise.all([\n      fetch('https://api.frobsco.com/v1/list'),\n      fetch('http://flerps.partnercompany.com:8080/flerp-batch'),\n      database.currentThunk(),\n    ]).then(async ([frobs, flerps, thunk]) => {\n      return computeAggregate(await frobs.json(), await flerps.json(), thunk);\n    });\n    res.status(200).json(agg);\n  });\n  /* highlight-add-end */\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"Then you can fetch the data from your frontend plugin like this:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",metastring:'title="plugins/frobs-aggregator/src/components/FrobsAggregator.tsx"',children:"import {\n  useApi,\n  discoveryApiRef,\n  fetchApiRef,\n} from '@backstage/core-plugin-api';\nimport useAsync from 'react-use/esm/useAsync';\n\nfunction FrobsAggregator() {\n  const fetchApi = useApi(fetchApiRef);\n  const discoveryApi = useApi(discoveryApiRef);\n\n  const { value, loading, error } = useAsync(async () => {\n    // highlight-next-line\n    const baseUrl = await discoveryApi.getBaseUrl('frobs-aggregator');\n    // highlight-next-line\n    const response = await fetchApi.fetch(`${baseUrl}/summary`);\n    return response.json();\n  }, [fetchApi, discoveryApi]);\n\n  // ...\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["For a more detailed example, see\n",(0,t.jsx)(n.a,{href:"https://github.com/backstage/backstage/tree/master/plugins/user-settings-backend",children:"the user-settings plugin backend"}),"\nthat stores some state in a database and surfaces an API for the frontend plugin to use."]}),"\n",(0,t.jsx)(n.p,{children:"Internally at Spotify, this has been a fairly popular choice for different\nreasons. Commonly, the backend has been used as a caching and data massaging\nlayer for slow APIs or APIs whose request/response shapes or speeds were not\nacceptable for direct use by frontends. For example, this has made it possible\nto issue efficient batch queries from the frontend, e.g. in big lists or tables\nthat want to resolve a lot of sparse data from the larger list that an\nunderlying service supplies."}),"\n",(0,t.jsx)(n.p,{children:"This may be used instead of the above, when:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"You need to perform complex model conversion, or protocol translation beyond\nwhat the proxy handles."}),"\n",(0,t.jsx)(n.li,{children:"You want to perform aggregations or summaries on the backend instead of on the\nfrontend."}),"\n",(0,t.jsx)(n.li,{children:"You want to enable batching or caching of slower or more unreliable APIs."}),"\n",(0,t.jsx)(n.li,{children:"You need to maintain state for your plugin, perhaps using the builtin database\nsupport in the backend."}),"\n",(0,t.jsx)(n.li,{children:"You need to inject secrets or in other ways negotiate with other parts of the\nAPI or other services in order to perform your work."}),"\n",(0,t.jsx)(n.li,{children:"You want to enforce end user authentication / authorization for operations on\nbehalf of the API, have session handling, or similar."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"There is a balance to strike regarding when to make an entirely separate backend\nfor a purpose, and when to make a Backstage backend plugin that adapts something\nthat already exists. General advice is not easy to give, but contact us on\nDiscord if you have any questions, and we may be able to offer guidance."})]})}function d(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},221020:(e,n,s)=>{var t=s(296540),i=Symbol.for("react.element"),r=Symbol.for("react.fragment"),a=Object.prototype.hasOwnProperty,o=t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,c={key:!0,ref:!0,__self:!0,__source:!0};function l(e,n,s){var t,r={},l=null,h=null;for(t in void 0!==s&&(l=""+s),void 0!==n.key&&(l=""+n.key),void 0!==n.ref&&(h=n.ref),n)a.call(n,t)&&!c.hasOwnProperty(t)&&(r[t]=n[t]);if(e&&e.defaultProps)for(t in n=e.defaultProps)void 0===r[t]&&(r[t]=n[t]);return{$$typeof:i,type:e,key:l,ref:h,props:r,_owner:o.current}}n.Fragment=r,n.jsx=l,n.jsxs=l},474848:(e,n,s)=>{e.exports=s(221020)},28453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>o});var t=s(296540);const i={},r=t.createContext(i);function a(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);